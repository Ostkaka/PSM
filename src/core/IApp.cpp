/*
* This is the IApp file governing all underlying game mechanics in an application
*/
#include <assert.h>
#include <core/IApp.hpp>
#include <core/IState.hpp>
#include <core/TextureHandler.hpp>
#include <iostream>

namespace psm
{
	/// Default application wide settings file string
	const char* IApp::APP_SETTINGS = "resources/settings.cfg";

	/// Single instance of the most recently created App class
	IApp* IApp::gApp = nullptr;

	// Implementations
	IApp::IApp( const std::string theTitle /*= "MGE Application"*/ ):
		mTitle(theTitle),
		mVideoMode(DEFAULT_VIDEO_WIDTH, DEFAULT_VIDEO_HEIGHT, DEFAULT_VIDEO_BPP),
		mWindow(),
		mContextSettings(),
		mWindowStyle(sf::Style::Close | sf::Style::Resize),		
		mExitCode(0),
		mRunning(false),
		mUpdateRate((int)(1.0f / 20.0f)) // 20 updates per second
	{
		// Save our global App pointer
		gApp = this;
	}

	IApp::~IApp()
	{
		//Set running flag to false
		mRunning = false;

		// Are we going out of scope? then remove our static pointer
		if(gApp == this)
		{
			gApp = nullptr;
		}
	}

	IApp* IApp::getApp()
	{
		return gApp;
	}

	void IApp::processArguments( int argc, char* argv[] )
	{
	}

	int IApp::run()
	{
		//Logger stuff
		//SLOG(App_Run,SeverityInfo) << std::endl;

		//Set running as true
		mRunning = true;

		//Register basic Assethandler
		mAssetManager.registerHandler(new(std::nothrow) TextureHandler());
		//mAssetManager.registerHandler(new(std::nothrow) MusicHandler());
		//mAssetManager.registerHandler(new(std::nothrow) SoundHandler());
		//mAssetManager.registerHandler(new(std::nothrow) FontHandler());

		// Register our App pointer with our StateManager
		mStateManager.registerApp(this);

		// Register Statmanager
		//mStatManager.registerApp(this);

		// Register custom asset classes
		initCustomAssetHandlers();

		// Load the application setting file settings.cfg
		initConfig();

		// pens and init the render window
		initRenderer();

		// Init the custom game states
		initCustomGameStates();

		// Do gameLoop of the running flag is active
		gameLoop();

		// Perform cleanup for custom configurations
		handleCustomCleanup();

		// Handle internal IApp cleaning
		cleanup();

		// Set running to be false
		mRunning = false;

		//Set exist code message
		/*if(mExitCode < 0)
			SLOGR(App_Run,SeverityError) << "exitCode=" << mExitCode << std::endl;
		else
			SLOGR(App_Run,SeverityInfo) << "exitCode=" << mExitCode << std::endl;
			*/
		// Return the exit code generated by quit
		return mExitCode;

	}

	bool IApp::isRunning() const
	{
		return mRunning;
	}
	
	float IApp::getUpdateRate(void) const
	{
		// Return the current set UpdateFixed game loop rate
		return (1000.0f / (float)(mUpdateRate));
	}

	void IApp::setUpdateRate(float rate)
	{
		if(200.0f >= rate && 1.0f <= rate)
		{
			//miliseconds
			mUpdateRate = (1000.0f / rate);
		}
	}

	void IApp::quit(int theExitCode)
	{
		mExitCode = theExitCode;
		mRunning = false;
	}

	void IApp::initConfig()
	{
		//SLOG(App_InitSettingsConfig, SeverityInfo) << std::endl;
		//ConfigAsset anSettingsConfig(IApp::APP_SETTINGS);
	}

	void IApp::initRenderer()
	{
		
		//SLOG(App_InitRenderer, SeverityInfo) << std::endl;
		//ConfigAsset anSettingsConfig(IApp::APP_SETTINGS);

		// Are we in Fullscreen mode?
		//if(anSettingsConfig.GetAsset().GetBool("window","fullscreen",false))
		//{
		//	mWindowStyle = sf::Style::Fullscreen;
		//}

		// What size window does the user want?
		/*mVideoMode.width =
			anSettingsConfig.GetAsset().GetUint32("window","width",DEFAULT_VIDEO_WIDTH);
		mVideoMode.height =
			anSettingsConfig.GetAsset().GetUint32("window","height",DEFAULT_VIDEO_HEIGHT);
		mVideoMode.bitsPerPixel =
			anSettingsConfig.GetAsset().GetUint32("window","depth",DEFAULT_VIDEO_BPP);*/

		// For Fullscreen, verify valid VideoMode, otherwise revert to defaults for Fullscreen
		if(sf::Style::Fullscreen == mWindowStyle && false == mVideoMode.isValid())
		/*{
			mVideoMode.width = DEFAULT_VIDEO_WIDTH;
			mVideoMode.height = DEFAULT_VIDEO_HEIGHT;
			mVideoMode.bitsPerPixel = DEFAULT_VIDEO_BPP;
		}*/

		mVideoMode.width = DEFAULT_VIDEO_WIDTH;
		mVideoMode.height = DEFAULT_VIDEO_HEIGHT;
		mVideoMode.bitsPerPixel = DEFAULT_VIDEO_BPP;
		
		// Create a RenderWindow object using VideoMode object above
		mWindow.create(mVideoMode, mTitle, mWindowStyle, mContextSettings);

		// Use Vertical Sync
		//mWindow.setVerticalSyncEnabled(true);

		sf::WindowHandle handle = mWindow.getSystemHandle();		
	}

	void IApp::gameLoop(void)
	{
		//SLOG(App_GameLoop, SeverityInfo) << std::endl;

		// Clock used in restricting Update loop to a fixed rate
		sf::Clock updateClock;
		
		// Restart/Reset our Update clock
		updateClock.restart();

		// Make sure we have at least one state active
		if(mStateManager.isEmpty())
		{
			// Exit with an error since there isn't an active state
			quit(StatusAppInitFailed);
		}

		// Loop while IsRunning returns true
		while(isRunning() && mWindow.isOpen() && !mStateManager.isEmpty())
		{
			// Get the currently active state
			IState& anState = mStateManager.getActiveState();

			// Count the number of sequential UpdateFixed loop calls
			int anUpdates = 0;

			DeltaTime timeSinceLastFrame = updateClock.getElapsedTime().asSeconds();

			if (mUpdateRate < timeSinceLastFrame)
			{
				// Process any available input
				processInput(anState);

				// Let the current active state perform its variable update
				// Convert to floating point value of seconds for SFML 2.0
				anState.update(timeSinceLastFrame);

				// Let the current active state draw stuff
				anState.draw();

				// Let the StatManager perform its drawing
				//mStatManager.draw();

				// Display Render window to the screen
				mWindow.display();

				// Give the state manager a chance to delete any pending states
				mStateManager.cleanup();

				updateClock.restart();
			}
		} 
	}

	void IApp::processInput(IState& theState)
	{
		// Variable for storing the current input event to be processed
		sf::Event tEvent;

		while(mWindow.pollEvent(tEvent))
		{
			// Handle some input events and let the current state handle the rest
			// Switch on Event Type
			switch(tEvent.type)
			{
			case sf::Event::Closed:       // Window closed
				quit(StatusAppOK);
				break;
			case sf::Event::GainedFocus:  // Window gained focus
				theState.resume();
				break;
			case sf::Event::LostFocus:    // Window lost focus
				theState.pause();
				break;
			case sf::Event::Resized:      // Window resized
				break;
			default:                      // Current active state will handle
				theState.handleEvents(tEvent);
				//std::cout << "Default " << std::endl;
			} 
		} 
	}

	void IApp::cleanup()
	{
		//SLOG(App_Cleanup, SeverityInfo) << std::endl;

		// Give the StatManager a chance to de-initialize
		//mStatManager.DeInit();

		// Close the Render window if it is still open
		if(mWindow.isOpen())
		{
			// Show the Mouse cursor
			mWindow.setMouseCursorVisible(true);

			// Close the Render window
			mWindow.close();
		}
	}
}